---
phase: 01-foundation---testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - web/package.json
  - web/vitest.config.mts
  - web/__tests__/setup.ts
  - web/lib/calculations/profit.test.ts
  - web/lib/calculations/efficiency.test.ts
  - web/app/api/jobs/route.test.ts
  - web/app/api/telemetry/route.test.ts
autonomous: true

must_haves:
  truths:
    - "Developer runs npm test and sees profit calculation tests pass"
    - "Developer runs npm test and sees efficiency calculation tests pass"
    - "Developer runs npm test and sees API route integration tests pass"
    - "Developer modifies calculateJobProfit and test catches regression"
    - "Tests run in watch mode during development"
  artifacts:
    - path: "web/vitest.config.mts"
      provides: "Vitest configuration with jsdom environment"
      min_lines: 15
    - path: "web/lib/calculations/profit.test.ts"
      provides: "Unit tests for all profit calculation functions"
      min_lines: 100
    - path: "web/lib/calculations/efficiency.test.ts"
      provides: "Unit tests for all efficiency calculation functions"
      min_lines: 80
    - path: "web/app/api/jobs/route.test.ts"
      provides: "Integration tests for jobs API route"
      min_lines: 50
    - path: "web/app/api/telemetry/route.test.ts"
      provides: "Integration tests for telemetry API route"
      min_lines: 50
  key_links:
    - from: "web/vitest.config.mts"
      to: "vite-tsconfig-paths"
      via: "plugins array"
      pattern: "tsconfigPaths\\(\\)"
    - from: "web/lib/calculations/profit.test.ts"
      to: "./profit"
      via: "import statement"
      pattern: "import.*from.*['\"]\\./profit['\"]"
    - from: "web/app/api/jobs/route.test.ts"
      to: "@supabase/supabase-js"
      via: "mock createClient"
      pattern: "vi\\.mock.*@supabase/supabase-js"
---

<objective>
Establish Vitest unit testing infrastructure and write comprehensive tests for profit/efficiency calculations and API routes.

Purpose: Enable safe refactoring of brownfield codebase by providing test coverage for critical business logic and API endpoints
Output: Working test suite with 60%+ coverage for calculation functions and API integration tests
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation---testing/01-RESEARCH.md
@.planning/codebase/STACK.md
@.planning/codebase/CONVENTIONS.md

# Existing calculation functions to test
@web/lib/calculations/profit.ts
@web/lib/calculations/efficiency.ts
</context>

<tasks>

<task type="auto">
  <name>Install Vitest and configure test environment</name>
  <files>
    web/package.json
    web/vitest.config.mts
    web/__tests__/setup.ts
  </files>
  <action>
    Install Vitest dependencies:
    ```bash
    cd web && npm install -D vitest @vitejs/plugin-react jsdom @testing-library/react @testing-library/dom vite-tsconfig-paths
    ```

    Create `web/vitest.config.mts` with configuration following RESEARCH.md pattern:
    - Import defineConfig from vitest/config
    - Import react plugin from @vitejs/plugin-react
    - Import tsconfigPaths from vite-tsconfig-paths
    - Set test.environment to 'jsdom' (required for DOM testing, even though these are pure function tests - establishes pattern)
    - Set test.globals to true (enables global test APIs like describe, test, expect)
    - Add plugins array with [tsconfigPaths(), react()] to resolve @/* path aliases
    - Add setupFiles pointing to '__tests__/setup.ts'

    Create `web/__tests__/setup.ts` as empty file for now (placeholder for future global setup)

    Add test scripts to package.json:
    - "test": "vitest" (watch mode for development)
    - "test:run": "vitest run" (single run for CI)

    CRITICAL: Use .mts extension for Vitest config (ES modules, Next.js 16 compatibility)
  </action>
  <verify>
    Run `cd web && npm test -- --version` and see Vitest version printed
    Run `cd web && npm test -- --run --reporter=verbose --bail` and see "No test files found" (expected - tests not written yet)
  </verify>
  <done>
    Vitest installed, config file created with jsdom environment and path alias resolution, test scripts available in package.json
  </done>
</task>

<task type="auto">
  <name>Write comprehensive unit tests for profit calculations</name>
  <files>
    web/lib/calculations/profit.test.ts
  </files>
  <action>
    Create `web/lib/calculations/profit.test.ts` following AAA (Arrange-Act-Assert) pattern from RESEARCH.md.

    Import test utilities:
    ```typescript
    import { describe, test, expect } from 'vitest'
    import {
      calculateFuelCost,
      calculateDamageCost,
      calculateJobProfit,
      calculateProfitPerMile,
      calculateTotalExpenses,
      calculateProfitMargin,
      ESTIMATED_FUEL_PRICE_PER_GALLON,
      MAX_REPAIR_COST
    } from './profit'
    ```

    Test coverage (minimum 12 tests):

    **calculateFuelCost:**
    - Normal case: 50 gallons -> $202.50
    - Zero fuel -> $0
    - Large number: 500 gallons

    **calculateDamageCost:**
    - 5% damage -> $500 (5/100 * 10000)
    - 0% damage -> $0
    - 100% damage -> $10000
    - 50% damage -> $5000

    **calculateJobProfit:**
    - Normal job with fuel and damage (income $5000, fuel 50gal, damage 5%) -> profit $4297.50
    - Perfect job (no fuel/damage) -> profit equals income
    - Null fuel_consumed and damage_taken -> treated as zero
    - High damage causing loss (income $3000, fuel 30gal, damage 50%) -> negative profit
    - Edge case: zero income -> negative profit

    **calculateProfitPerMile:**
    - Positive profit: $500 profit / 100 miles -> $5/mile
    - Zero distance -> 0 (avoid division by zero)
    - Negative profit -> negative profit per mile

    **calculateTotalExpenses:**
    - Returns object with fuelCost, damageCost, total
    - Verify breakdown matches individual calculations

    **calculateProfitMargin:**
    - 20% margin case
    - Zero revenue -> 0
    - 100% margin (no expenses)

    Use toBeCloseTo(value, 2) for floating point comparisons (avoid 0.0000001 errors)
    Use toBe() for exact integers
    Test edge cases: null, undefined, zero, negative numbers

    **IMPORTANT:** Run tests incrementally during development to verify imports and logic work correctly. Use `npm test profit.test.ts` in watch mode while writing tests.
  </action>
  <verify>
    Run `cd web && npm test profit.test.ts -- --run` and see all profit tests pass
    Run `cd web && npm test profit.test.ts -- --run --coverage` and see 100% coverage for profit.ts
  </verify>
  <done>
    profit.test.ts exists with 12+ passing tests covering all functions and edge cases, using toBeCloseTo for decimal assertions
  </done>
</task>

<task type="auto">
  <name>Write comprehensive unit tests for efficiency calculations</name>
  <files>
    web/lib/calculations/efficiency.test.ts
  </files>
  <action>
    Create `web/lib/calculations/efficiency.test.ts` following same AAA pattern.

    Import test utilities:
    ```typescript
    import { describe, test, expect } from 'vitest'
    import {
      calculateMPG,
      calculateFuelRange,
      calculateFuelEfficiencyPercentage,
      calculateEstimatedFuelCost,
      calculateAverageSpeed,
      calculateTimeEfficiency
    } from './efficiency'
    ```

    Test coverage (minimum 10 tests):

    **calculateMPG:**
    - Normal case: 400 miles / 50 gallons -> 8 MPG
    - Zero fuel -> 0 (avoid division by zero)
    - High efficiency: 500 miles / 25 gallons -> 20 MPG

    **calculateFuelRange:**
    - 60 gallons * 4.75 MPG -> 285 miles
    - Zero fuel -> 0 miles
    - Zero MPG -> 0 miles

    **calculateFuelEfficiencyPercentage:**
    - Better than average: current 10 MPG, avg 8 MPG -> +25%
    - Worse than average: current 6 MPG, avg 8 MPG -> -25%
    - Zero average -> 0

    **calculateEstimatedFuelCost:**
    - 200 miles remaining, 8 MPG, $4.05/gal -> $101.25
    - Zero MPG -> $0
    - Zero distance -> $0

    **calculateAverageSpeed:**
    - 400 miles / 8 hours -> 50 mph
    - Zero time -> 0

    **calculateTimeEfficiency:**
    - Faster than estimated: 7 hours actual / 8 hours estimated -> 114%
    - Slower than estimated: 9 hours actual / 8 hours estimated -> 88%
    - Zero estimated -> 100%

    Use toBeCloseTo() for all decimal results
    Test all division-by-zero cases return 0 (not Infinity or NaN)

    **IMPORTANT:** Run tests incrementally to verify logic (`npm test efficiency.test.ts` in watch mode).
  </action>
  <verify>
    Run `cd web && npm test efficiency.test.ts -- --run` and see all efficiency tests pass
    Run `cd web && npm test -- --run` and see both profit and efficiency test suites pass
  </verify>
  <done>
    efficiency.test.ts exists with 10+ passing tests covering all functions and edge cases, all division-by-zero cases handled safely
  </done>
</task>

<task type="auto">
  <name>Write integration tests for API routes</name>
  <files>
    web/app/api/jobs/route.test.ts
    web/app/api/telemetry/route.test.ts
  </files>
  <action>
    Create integration tests for API routes following RESEARCH.md Vitest + Next.js patterns.

    **File: web/app/api/jobs/route.test.ts**

    Import test utilities:
    ```typescript
    import { describe, test, expect, vi, beforeEach } from 'vitest'
    import { GET, POST } from './route'
    import { createClient } from '@/lib/supabase/server'
    ```

    Mock Supabase client:
    ```typescript
    vi.mock('@/lib/supabase/server', () => ({
      createClient: vi.fn()
    }))
    ```

    Test coverage (minimum 6 tests):

    **GET /api/jobs:**
    - Returns 200 with jobs array for authenticated user
    - Returns empty array when no jobs exist
    - Handles Supabase errors gracefully (returns 500)

    **POST /api/jobs:**
    - Creates new job and returns 201 with job data
    - Validates required fields (returns 400 if missing)
    - Handles database errors (returns 500)

    **File: web/app/api/telemetry/route.test.ts**

    Import test utilities:
    ```typescript
    import { describe, test, expect, vi, beforeEach } from 'vitest'
    import { POST } from './route'
    import { createClient } from '@/lib/supabase/server'
    ```

    Mock Supabase client (same pattern as jobs)

    Test coverage (minimum 4 tests):

    **POST /api/telemetry:**
    - Accepts telemetry data and returns 201
    - Validates required fields (speed, rpm, fuel_current)
    - Associates telemetry with active job_id if provided
    - Handles database errors gracefully

    Use vi.fn() to mock Supabase methods:
    ```typescript
    const mockFrom = vi.fn().mockReturnValue({
      select: vi.fn().mockResolvedValue({ data: [], error: null })
    })
    createClient.mockReturnValue({ from: mockFrom })
    ```

    **IMPORTANT:** These are integration tests verifying request/response contracts, not full E2E (no real database)
    **IMPORTANT:** Mock Supabase client responses, don't hit actual database
  </action>
  <verify>
    Run `cd web && npm test route.test.ts -- --run` and see all API route tests pass
    Verify mocked Supabase client doesn't make real database calls
    Run `cd web && npm test -- --run` and see all test suites pass (profit, efficiency, jobs, telemetry)
  </verify>
  <done>
    API route integration tests exist for /api/jobs and /api/telemetry with mocked Supabase client, verifying request/response contracts and error handling
  </done>
</task>

</tasks>

<verification>
Run `cd web && npm test -- --run --reporter=verbose` and see:
- All profit calculation tests pass (12+ tests)
- All efficiency calculation tests pass (10+ tests)
- All API route integration tests pass (10+ tests)
- No test failures or errors
- Test execution completes in under 10 seconds
</verification>

<success_criteria>
- Developer runs `npm test` in web directory and sees passing test suite
- profit.test.ts covers calculateJobProfit, calculateProfitPerMile, calculateTotalExpenses with edge cases
- efficiency.test.ts covers calculateMPG, calculateFuelRange with division-by-zero handling
- API route tests verify /api/jobs and /api/telemetry request/response contracts
- Test configuration uses jsdom environment and resolves @/* path aliases
- Tests use toBeCloseTo() for floating point comparisons avoiding precision errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation---testing/01-01-SUMMARY.md`
</output>
