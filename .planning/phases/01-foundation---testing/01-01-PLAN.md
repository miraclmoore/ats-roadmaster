---
phase: 01-foundation---testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - web/package.json
  - web/vitest.config.mts
  - web/__tests__/setup.ts
  - web/lib/calculations/profit.test.ts
  - web/lib/calculations/efficiency.test.ts
autonomous: true

must_haves:
  truths:
    - "Developer runs npm test and sees profit calculation tests pass"
    - "Developer runs npm test and sees efficiency calculation tests pass"
    - "Developer modifies calculateJobProfit and test catches regression"
    - "Tests run in watch mode during development"
  artifacts:
    - path: "web/vitest.config.mts"
      provides: "Vitest configuration with jsdom environment"
      min_lines: 15
    - path: "web/lib/calculations/profit.test.ts"
      provides: "Unit tests for all profit calculation functions"
      min_lines: 100
    - path: "web/lib/calculations/efficiency.test.ts"
      provides: "Unit tests for all efficiency calculation functions"
      min_lines: 80
  key_links:
    - from: "web/vitest.config.mts"
      to: "vite-tsconfig-paths"
      via: "plugins array"
      pattern: "tsconfigPaths\\(\\)"
    - from: "web/lib/calculations/profit.test.ts"
      to: "./profit"
      via: "import statement"
      pattern: "import.*from.*['\"]\\./profit['\"]"
---

<objective>
Establish Vitest unit testing infrastructure and write comprehensive tests for profit and efficiency calculation functions.

Purpose: Enable safe refactoring of brownfield codebase by providing test coverage for critical business logic
Output: Working test suite with 60%+ coverage for calculation functions
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation---testing/01-RESEARCH.md
@.planning/codebase/STACK.md
@.planning/codebase/CONVENTIONS.md

# Existing calculation functions to test
@web/lib/calculations/profit.ts
@web/lib/calculations/efficiency.ts
</context>

<tasks>

<task type="auto">
  <name>Install Vitest and configure test environment</name>
  <files>
    web/package.json
    web/vitest.config.mts
    web/__tests__/setup.ts
  </files>
  <action>
    Install Vitest dependencies:
    ```bash
    cd web && npm install -D vitest @vitejs/plugin-react jsdom @testing-library/react @testing-library/dom vite-tsconfig-paths
    ```

    Create `web/vitest.config.mts` with configuration following RESEARCH.md pattern:
    - Import defineConfig from vitest/config
    - Import react plugin from @vitejs/plugin-react
    - Import tsconfigPaths from vite-tsconfig-paths
    - Set test.environment to 'jsdom' (required for DOM testing, even though these are pure function tests - establishes pattern)
    - Set test.globals to true (enables global test APIs like describe, test, expect)
    - Add plugins array with [tsconfigPaths(), react()] to resolve @/* path aliases
    - Add setupFiles pointing to '__tests__/setup.ts'

    Create `web/__tests__/setup.ts` as empty file for now (placeholder for future global setup)

    Add test scripts to package.json:
    - "test": "vitest" (watch mode for development)
    - "test:run": "vitest run" (single run for CI)

    CRITICAL: Use .mts extension for Vitest config (ES modules, Next.js 16 compatibility)
  </action>
  <verify>
    Run `cd web && npm test -- --version` and see Vitest version printed
    Run `cd web && npm test -- --run --reporter=verbose --bail` and see "No test files found" (expected - tests not written yet)
  </verify>
  <done>
    Vitest installed, config file created with jsdom environment and path alias resolution, test scripts available in package.json
  </done>
</task>

<task type="auto">
  <name>Write comprehensive unit tests for profit calculations</name>
  <files>
    web/lib/calculations/profit.test.ts
  </files>
  <action>
    Create `web/lib/calculations/profit.test.ts` following AAA (Arrange-Act-Assert) pattern from RESEARCH.md.

    Import test utilities:
    ```typescript
    import { describe, test, expect } from 'vitest'
    import {
      calculateFuelCost,
      calculateDamageCost,
      calculateJobProfit,
      calculateProfitPerMile,
      calculateTotalExpenses,
      calculateProfitMargin,
      ESTIMATED_FUEL_PRICE_PER_GALLON,
      MAX_REPAIR_COST
    } from './profit'
    ```

    Test coverage (minimum 12 tests):

    **calculateFuelCost:**
    - Normal case: 50 gallons -> $202.50
    - Zero fuel -> $0
    - Large number: 500 gallons

    **calculateDamageCost:**
    - 5% damage -> $500 (5/100 * 10000)
    - 0% damage -> $0
    - 100% damage -> $10000
    - 50% damage -> $5000

    **calculateJobProfit:**
    - Normal job with fuel and damage (income $5000, fuel 50gal, damage 5%) -> profit $4297.50
    - Perfect job (no fuel/damage) -> profit equals income
    - Null fuel_consumed and damage_taken -> treated as zero
    - High damage causing loss (income $3000, fuel 30gal, damage 50%) -> negative profit
    - Edge case: zero income -> negative profit

    **calculateProfitPerMile:**
    - Positive profit: $500 profit / 100 miles -> $5/mile
    - Zero distance -> 0 (avoid division by zero)
    - Negative profit -> negative profit per mile

    **calculateTotalExpenses:**
    - Returns object with fuelCost, damageCost, total
    - Verify breakdown matches individual calculations

    **calculateProfitMargin:**
    - 20% margin case
    - Zero revenue -> 0
    - 100% margin (no expenses)

    Use toBeCloseTo(value, 2) for floating point comparisons (avoid 0.0000001 errors)
    Use toBe() for exact integers
    Test edge cases: null, undefined, zero, negative numbers
  </action>
  <verify>
    Run `cd web && npm test profit.test.ts -- --run` and see all profit tests pass
    Run `cd web && npm test profit.test.ts -- --run --coverage` and see 100% coverage for profit.ts
  </verify>
  <done>
    profit.test.ts exists with 12+ passing tests covering all functions and edge cases, using toBeCloseTo for decimal assertions
  </done>
</task>

<task type="auto">
  <name>Write comprehensive unit tests for efficiency calculations</name>
  <files>
    web/lib/calculations/efficiency.test.ts
  </files>
  <action>
    Create `web/lib/calculations/efficiency.test.ts` following same AAA pattern.

    Import test utilities:
    ```typescript
    import { describe, test, expect } from 'vitest'
    import {
      calculateMPG,
      calculateFuelRange,
      calculateFuelEfficiencyPercentage,
      calculateEstimatedFuelCost,
      calculateAverageSpeed,
      calculateTimeEfficiency
    } from './efficiency'
    ```

    Test coverage (minimum 10 tests):

    **calculateMPG:**
    - Normal case: 400 miles / 50 gallons -> 8 MPG
    - Zero fuel -> 0 (avoid division by zero)
    - High efficiency: 500 miles / 25 gallons -> 20 MPG

    **calculateFuelRange:**
    - 60 gallons * 4.75 MPG -> 285 miles
    - Zero fuel -> 0 miles
    - Zero MPG -> 0 miles

    **calculateFuelEfficiencyPercentage:**
    - Better than average: current 10 MPG, avg 8 MPG -> +25%
    - Worse than average: current 6 MPG, avg 8 MPG -> -25%
    - Zero average -> 0

    **calculateEstimatedFuelCost:**
    - 200 miles remaining, 8 MPG, $4.05/gal -> $101.25
    - Zero MPG -> $0
    - Zero distance -> $0

    **calculateAverageSpeed:**
    - 400 miles / 8 hours -> 50 mph
    - Zero time -> 0

    **calculateTimeEfficiency:**
    - Faster than estimated: 7 hours actual / 8 hours estimated -> 114%
    - Slower than estimated: 9 hours actual / 8 hours estimated -> 88%
    - Zero estimated -> 100%

    Use toBeCloseTo() for all decimal results
    Test all division-by-zero cases return 0 (not Infinity or NaN)
  </action>
  <verify>
    Run `cd web && npm test efficiency.test.ts -- --run` and see all efficiency tests pass
    Run `cd web && npm test -- --run` and see both profit and efficiency test suites pass
  </verify>
  <done>
    efficiency.test.ts exists with 10+ passing tests covering all functions and edge cases, all division-by-zero cases handled safely
  </done>
</task>

</tasks>

<verification>
Run `cd web && npm test -- --run --reporter=verbose` and see:
- All profit calculation tests pass (12+ tests)
- All efficiency calculation tests pass (10+ tests)
- No test failures or errors
- Test execution completes in under 10 seconds
</verification>

<success_criteria>
- Developer runs `npm test` in web directory and sees passing test suite
- profit.test.ts covers calculateJobProfit, calculateProfitPerMile, calculateTotalExpenses with edge cases
- efficiency.test.ts covers calculateMPG, calculateFuelRange with division-by-zero handling
- Test configuration uses jsdom environment and resolves @/* path aliases
- Tests use toBeCloseTo() for floating point comparisons avoiding precision errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation---testing/01-01-SUMMARY.md`
</output>
