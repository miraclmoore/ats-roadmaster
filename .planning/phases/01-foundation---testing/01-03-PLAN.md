---
phase: 01-foundation---testing
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/tests/001-database.test.sql
  - supabase/tests/002-rls.test.sql
  - web/package.json
autonomous: true

must_haves:
  truths:
    - "Developer runs npm run test:db and sees database schema tests pass"
    - "Developer runs npm run test:db and sees RLS policy tests pass"
    - "Tests verify users can only access their own jobs and telemetry data"
    - "Tests verify profit/fuel_cost/damage_cost fields exist in schema for calculation storage"
  artifacts:
    - path: "supabase/tests/001-database.test.sql"
      provides: "pgTAP tests for database schema and constraints"
      min_lines: 50
    - path: "supabase/tests/002-rls.test.sql"
      provides: "pgTAP tests for Row Level Security policies"
      min_lines: 80
  key_links:
    - from: "supabase/tests/002-rls.test.sql"
      to: "tests.authenticate_as"
      via: "user context switching"
      pattern: "tests\\.authenticate_as"
    - from: "supabase/tests/001-database.test.sql"
      to: "public.jobs"
      via: "table testing"
      pattern: "INSERT INTO.*jobs"
---

<objective>
Establish pgTAP database testing infrastructure and verify Row Level Security policies and database schema function correctly.

Purpose: Ensure data isolation between users and profit calculation fields exist at database level
Output: Automated database tests that can run in local Supabase instance and CI
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation---testing/01-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@CLAUDE.md

# Database schema to test
Schema documented in CLAUDE.md under "DATABASE SCHEMA"
</context>

<tasks>

<task type="auto">
  <name>Set up pgTAP testing infrastructure</name>
  <files>
    web/package.json
  </files>
  <action>
    Add database test scripts to web/package.json:
    ```json
    "test:db": "supabase db test",
    "test:db:watch": "supabase db test --watch"
    ```

    Create directory for database tests if not exists:
    ```bash
    mkdir -p supabase/tests
    ```

    Document requirements in comments at top of each test file:
    - Requires Supabase CLI installed (`brew install supabase/tap/supabase` or `npm install -g supabase`)
    - Requires local Supabase instance running (`supabase start`)
    - Tests run against local database, not production

    pgTAP should already be installed in Supabase local instance (comes by default).

    IMPORTANT: These tests require Supabase CLI and local instance running
    IMPORTANT: Document in each test file: "Run 'supabase start' before running tests"
  </action>
  <verify>
    Run `cd web && supabase --version` and see Supabase CLI version
    Verify supabase/tests/ directory exists
    Check package.json contains test:db script
  </verify>
  <done>
    Database test scripts added to package.json, test directory created, documentation comments prepared
  </done>
</task>

<task type="auto">
  <name>Write database schema and constraint tests</name>
  <files>
    supabase/tests/001-database.test.sql
  </files>
  <action>
    Create `supabase/tests/001-database.test.sql` with pgTAP tests for database functionality.

    Header comment:
    ```sql
    -- Database Tests: Schema Structure, Constraints, and Calculated Fields
    -- Requirements: Supabase CLI, local instance running ('supabase start')
    -- Run: npm run test:db
    ```

    Test structure using pgTAP functions:

    BEGIN transaction
    SELECT plan(N) where N = number of tests

    **Test 1: Jobs table has required columns**
    - Use has_column('public', 'jobs', 'user_id')
    - Use has_column('public', 'jobs', 'income')
    - Use has_column('public', 'jobs', 'profit')
    - Use has_column('public', 'jobs', 'fuel_cost')
    - Use has_column('public', 'jobs', 'damage_cost')

    **Test 2: Jobs table has correct constraints**
    - Use col_not_null('public', 'jobs', 'user_id')
    - Use col_not_null('public', 'jobs', 'income')

    **Test 3: Telemetry table has required structure**
    - Use has_table('public', 'telemetry')
    - Use has_column('public', 'telemetry', 'speed')
    - Use has_column('public', 'telemetry', 'rpm')
    - Use has_column('public', 'telemetry', 'fuel_current')

    **Test 4: Jobs table has indexes for performance**
    - Use has_index('public', 'jobs', 'idx_jobs_user_id')
    - Use has_index('public', 'jobs', 'idx_jobs_completed_at')

    **Test 5: Foreign key relationships exist**
    - Use has_fk('public', 'jobs', 'user_id references auth.users')
    - Use has_fk('public', 'telemetry', 'job_id references jobs')

    **Test 6: Profit calculation fields exist**
    - Verify jobs.profit column exists (DECIMAL type)
    - Verify jobs.fuel_cost column exists (DECIMAL type)
    - Verify jobs.damage_cost column exists (DECIMAL type)
    - These fields store pre-calculated values from profit calculations

    SELECT * FROM finish()
    ROLLBACK

    Total: Plan for 15-20 tests covering schema structure

    CRITICAL: Wrap tests in BEGIN/ROLLBACK to avoid polluting database
    CRITICAL: Use SELECT plan(N) at start, SELECT * FROM finish() at end
    CRITICAL: Test verifies profit calculation FIELDS exist (not triggers - calculations done in app layer)
  </action>
  <verify>
    Run `cd web && npm run test:db` and see database structure tests pass
    Verify all table structure assertions succeed
  </verify>
  <done>
    001-database.test.sql exists with 15+ tests verifying jobs and telemetry table structure, indexes, constraints, and profit calculation field schema
  </done>
</task>

<task type="auto">
  <name>Write Row Level Security policy tests</name>
  <files>
    supabase/tests/002-rls.test.sql
  </files>
  <action>
    Create `supabase/tests/002-rls.test.sql` with pgTAP tests for RLS policies following RESEARCH.md patterns.

    Header comment:
    ```sql
    -- Row Level Security Tests: User data isolation
    -- Requirements: Supabase CLI, local instance running
    -- Run: npm run test:db
    ```

    Test structure:

    BEGIN transaction
    SELECT plan(N) where N = number of tests

    **Setup: Create test users**
    ```sql
    SELECT tests.create_supabase_user('test_user_1');
    SELECT tests.create_supabase_user('test_user_2');
    ```

    **Test 1: RLS is enabled on jobs table**
    - SELECT tests.rls_enabled('public', 'jobs')

    **Test 2: RLS is enabled on telemetry table**
    - SELECT tests.rls_enabled('public', 'telemetry')

    **Test 3: User can insert their own jobs**
    - SELECT tests.authenticate_as('test_user_1')
    - INSERT INTO jobs (user_id, source_city, destination_city, cargo_type, income, distance, started_at) VALUES ('test_user_1', 'LA', 'SF', 'Electronics', 5000, 400, NOW())
    - SELECT is((SELECT COUNT(*)::int FROM jobs WHERE user_id = 'test_user_1'), 1, 'User can insert own job')

    **Test 4: User can see their own jobs**
    - SELECT tests.authenticate_as('test_user_1')
    - SELECT is((SELECT COUNT(*)::int FROM jobs WHERE user_id = 'test_user_1'), 1, 'User can see own jobs')

    **Test 5: User cannot see other users' jobs**
    - INSERT job for test_user_2 (using service role or other mechanism)
    - SELECT tests.authenticate_as('test_user_1')
    - SELECT is((SELECT COUNT(*)::int FROM jobs WHERE user_id = 'test_user_2'), 0, 'User cannot see other users jobs')

    **Test 6: User can update their own jobs**
    - SELECT tests.authenticate_as('test_user_1')
    - UPDATE jobs SET completed_at = NOW() WHERE user_id = 'test_user_1'
    - Verify update succeeded

    **Test 7: User cannot update other users' jobs**
    - SELECT tests.authenticate_as('test_user_1')
    - Attempt UPDATE on test_user_2's job
    - Verify no rows affected

    **Test 8-10: Repeat similar tests for telemetry table**
    - User can insert own telemetry
    - User can see own telemetry
    - User cannot see other users' telemetry

    **Test 11: RLS policy on user_preferences**
    - SELECT tests.rls_enabled('public', 'user_preferences')

    SELECT * FROM finish()
    ROLLBACK

    Total: Plan for 12-15 tests covering all RLS policies

    IMPORTANT: Use tests.authenticate_as() to switch user context
    IMPORTANT: Verify service role bypass doesn't affect these tests (tests run as authenticated users)
  </action>
  <verify>
    Run `cd web && npm run test:db` and see all RLS tests pass
    Verify user isolation tests confirm users cannot access each other's data
  </verify>
  <done>
    002-rls.test.sql exists with 12+ tests verifying RLS policies prevent cross-user data access for jobs, telemetry, and preferences tables
  </done>
</task>

</tasks>

<verification>
Run `cd web && npm run test:db` and see:
- 001-database.test.sql passes all structure tests
- 002-rls.test.sql passes all RLS isolation tests
- All tests complete successfully with no failures
- pgTAP output shows test plan and results clearly
</verification>

<success_criteria>
- Developer runs `npm run test:db` and sees all database tests pass
- RLS tests verify users can only see their own jobs and telemetry
- Database structure tests verify required columns (including profit/fuel_cost/damage_cost), indexes, and constraints exist
- Tests use BEGIN/ROLLBACK to avoid polluting database
- Tests use tests.authenticate_as() to properly test user context
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation---testing/01-03-SUMMARY.md`
</output>
