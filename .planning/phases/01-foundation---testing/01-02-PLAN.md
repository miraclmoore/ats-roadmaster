---
phase: 01-foundation---testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - web/package.json
  - web/playwright.config.ts
  - web/e2e/live-telemetry.spec.ts
  - web/__tests__/components/live-dashboard.test.tsx
autonomous: true

must_haves:
  truths:
    - "Developer runs npm run test:e2e and sees browser automation testing live telemetry flow"
    - "Test verifies user can see live dashboard when unauthenticated (redirects to login)"
    - "Component tests verify real-time telemetry subscription setup with mocked WebSocket"
    - "Test handles empty state when no telemetry available"
    - "Test runs in headless mode suitable for CI"
  artifacts:
    - path: "web/playwright.config.ts"
      provides: "Playwright configuration with baseURL and webServer"
      min_lines: 30
    - path: "web/e2e/live-telemetry.spec.ts"
      provides: "E2E test for live telemetry page"
      min_lines: 50
    - path: "web/__tests__/components/live-dashboard.test.tsx"
      provides: "Component tests with Supabase real-time mocking"
      min_lines: 80
  key_links:
    - from: "web/playwright.config.ts"
      to: "npm run dev"
      via: "webServer.command"
      pattern: "command:.*npm run dev"
    - from: "web/e2e/live-telemetry.spec.ts"
      to: "/live"
      via: "page.goto"
      pattern: "page\\.goto\\(['\"][^'\"]*live"
    - from: "web/__tests__/components/live-dashboard.test.tsx"
      to: "@supabase/supabase-js"
      via: "mock createClient"
      pattern: "vi\\.mock.*@supabase/supabase-js"
---

<objective>
Establish Playwright E2E testing infrastructure and verify real-time telemetry flow works end-to-end, including component-level tests with WebSocket mocking.

Purpose: Ensure critical user journey (viewing live telemetry) works across authentication, data fetching, and real-time updates
Output: Working E2E test suite that can run in CI pipeline plus component tests with mocked Supabase real-time
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation---testing/01-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

# Live telemetry page structure
@web/app/(dashboard)/live/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Install Playwright and configure E2E environment</name>
  <files>
    web/package.json
    web/playwright.config.ts
  </files>
  <action>
    Install Playwright using official init command:
    ```bash
    cd web && npm init playwright@latest -- --yes --install-deps --browser=chromium --browser=firefox --browser=webkit --gha
    ```

    This automatically creates playwright.config.ts with defaults. Modify the generated config:

    Key settings to verify/update:
    - testDir: './e2e' (not './tests' - use e2e directory)
    - fullyParallel: true (run tests in parallel)
    - forbidOnly: !!process.env.CI (prevent .only in CI)
    - retries: process.env.CI ? 2 : 0 (retry flaky tests in CI)
    - workers: process.env.CI ? 1 : undefined (1 worker in CI, auto locally)
    - reporter: 'html' (generate HTML report)
    - use.baseURL: 'http://localhost:3000' (use relative paths in tests)
    - use.trace: 'on-first-retry' (collect trace on retry for debugging)
    - projects: chromium, firefox, webkit (all three browsers)
    - webServer.command: 'npm run dev'
    - webServer.url: 'http://localhost:3000'
    - webServer.reuseExistingServer: !process.env.CI (reuse dev server locally)

    Add test script to package.json:
    - "test:e2e": "playwright test"
    - "test:e2e:ui": "playwright test --ui" (interactive mode)

    CRITICAL: Do NOT hardcode localhost:3000 in test files - use relative paths with baseURL
  </action>
  <verify>
    Run `cd web && npx playwright --version` and see Playwright version
    Run `cd web && npx playwright test --list` and see "no tests found" (expected - not written yet)
    Check that web/playwright.config.ts exists with webServer.command set to 'npm run dev'
  </verify>
  <done>
    Playwright installed with chromium/firefox/webkit browsers, config file created with baseURL and dev server setup, test scripts added to package.json
  </done>
</task>

<task type="auto">
  <name>Write E2E test for live telemetry page (unauthenticated flow)</name>
  <files>
    web/e2e/live-telemetry.spec.ts
  </files>
  <action>
    Create `web/e2e/live-telemetry.spec.ts` to test the unauthenticated user journey for live telemetry page.

    Import Playwright test utilities:
    ```typescript
    import { test, expect } from '@playwright/test'
    ```

    Test structure (3 test cases):

    **Test 1: "redirects to login when unauthenticated"**
    - Navigate to '/live'
    - Expect redirect to '/login' or see login form
    - Verify page URL contains 'login' or 'auth'
    - This is the EXPECTED behavior for protected routes

    **Test 2: "page loads without errors"**
    - Navigate to '/live' directly
    - Wait for page load (may redirect to login)
    - Verify no JavaScript console errors logged
    - Check page renders (either login form or dashboard)

    **Test 3: "live page has expected layout structure (if accessible)"**
    - Navigate to '/live'
    - If redirected to login, skip layout checks
    - If accessible (mock auth in future), verify PageHeader component renders
    - Check for dashboard layout (cards, gauges expected structure)
    - Verify sidebar navigation is visible (desktop) or menu button (mobile)

    Use Playwright's auto-waiting (do NOT use manual sleep):
    - page.goto() waits for load event
    - page.locator() waits for element to be visible
    - expect(locator).toBeVisible() waits up to 5s

    Handle authentication:
    - Test UNAUTHENTICATED behavior (redirect to login is success)
    - Add comment: "TODO: Add authentication setup for authenticated tests in future phase"
    - Document that these are unauthenticated smoke tests verifying page doesn't crash

    IMPORTANT: Use relative paths (page.goto('/live')) not absolute URLs
    IMPORTANT: These are smoke tests - unauthenticated flow only, authenticated testing deferred
  </action>
  <verify>
    Run `cd web && npm run test:e2e` and see tests execute in headless browsers
    Verify test output shows 3 tests running across chromium/firefox/webkit
    Tests should pass with redirect to login (expected unauthenticated behavior)
  </verify>
  <done>
    live-telemetry.spec.ts exists with 3 smoke tests verifying unauthenticated page redirect to login, no crashes, tests document this is expected behavior
  </done>
</task>

<task type="auto">
  <name>Write component tests with Supabase real-time WebSocket mocking</name>
  <files>
    web/__tests__/components/live-dashboard.test.tsx
  </files>
  <action>
    Create `web/__tests__/components/live-dashboard.test.tsx` to test real-time telemetry subscription component with mocked WebSocket.

    Import test utilities:
    ```typescript
    import { describe, test, expect, vi, beforeEach } from 'vitest'
    import { render, screen, waitFor } from '@testing-library/react'
    import { createClient } from '@/lib/supabase/client'
    ```

    Mock Supabase client with real-time channel:
    ```typescript
    const mockChannel = {
      on: vi.fn().mockReturnThis(),
      subscribe: vi.fn().mockResolvedValue({ status: 'SUBSCRIBED' }),
      unsubscribe: vi.fn()
    }

    const mockSupabase = {
      channel: vi.fn(() => mockChannel),
      removeChannel: vi.fn()
    }

    vi.mock('@/lib/supabase/client', () => ({
      createClient: vi.fn(() => mockSupabase)
    }))
    ```

    Find or create a component that uses Supabase real-time (likely LiveDashboard or similar).
    If no such component exists yet, create a minimal test component:
    ```typescript
    function TestLiveTelemetry({ userId }: { userId: string }) {
      const [telemetry, setTelemetry] = useState(null)
      const supabase = createClient()

      useEffect(() => {
        const channel = supabase
          .channel('telemetry')
          .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'telemetry' },
            (payload) => setTelemetry(payload.new))
          .subscribe()

        return () => supabase.removeChannel(channel)
      }, [userId])

      return <div>{telemetry ? 'Telemetry Active' : 'Waiting for data'}</div>
    }
    ```

    Test coverage (minimum 5 tests):

    **Test 1: "renders waiting state initially"**
    - Render component with test userId
    - Expect "Waiting for data" message
    - Verify no telemetry displayed

    **Test 2: "subscribes to Supabase real-time channel on mount"**
    - Render component
    - Verify createClient().channel() called
    - Verify channel.on() called with 'postgres_changes'
    - Verify channel.subscribe() called

    **Test 3: "updates UI when telemetry data received"**
    - Render component
    - Simulate WebSocket message by calling the 'on' callback
    - Verify UI updates to show telemetry data

    **Test 4: "unsubscribes from channel on unmount"**
    - Render component
    - Unmount component
    - Verify removeChannel called (cleanup)

    **Test 5: "filters telemetry by user_id"**
    - Verify channel.on() called with correct filter
    - Simulate message with different user_id
    - Verify only own user's data shown

    **IMPORTANT:** Mock the Supabase real-time WebSocket, don't hit actual Supabase
    **IMPORTANT:** Test component behavior, not Supabase SDK (that's their responsibility)
  </action>
  <verify>
    Run `cd web && npm test live-dashboard.test.tsx -- --run` and see all component tests pass
    Verify mocked channel subscription called correctly
    Run `cd web && npm test -- --run` and see all test suites pass
  </verify>
  <done>
    Component tests exist with mocked Supabase real-time channel, verifying subscription setup, data updates, and cleanup without real WebSocket connections
  </done>
</task>

</tasks>

<verification>
Run `cd web && npm run test:e2e -- --reporter=list` and see:
- live-telemetry.spec.ts tests execute
- Tests run in all three browsers (chromium, firefox, webkit)
- Dev server starts automatically before tests
- Tests complete without crashes or timeouts (unauthenticated redirect is success)
- HTML report generated in playwright-report/

Run `cd web && npm test -- --run` and see:
- Component tests for real-time subscription pass
- Mocked WebSocket behavior verified
</verification>

<success_criteria>
- Developer runs `npm run test:e2e` and sees Playwright execute cross-browser tests
- live-telemetry.spec.ts verifies unauthenticated users redirect to login (expected behavior)
- Component tests verify Supabase real-time subscription setup with mocked WebSocket
- Tests use baseURL config and relative paths (no hardcoded localhost:3000)
- Playwright config includes webServer that auto-starts Next.js dev server
- Tests run in headless mode suitable for CI execution
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation---testing/01-02-SUMMARY.md`
</output>
