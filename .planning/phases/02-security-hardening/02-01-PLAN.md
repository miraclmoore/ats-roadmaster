---
phase: 02-security-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - web/lib/ratelimit.ts
  - web/.env.local
  - web/package.json
  - web/package-lock.json
autonomous: true

must_haves:
  truths:
    - Developer can import rate limiters with different thresholds for different endpoint types
    - Upstash Redis client connects successfully with environment variables
    - Rate limiter uses sliding window algorithm to prevent boundary exploitation
    - Telemetry limiter allows 7200 requests/hour (2x buffer for 1Hz SDK)
    - Mutation limiter allows 100 requests/hour for job operations
    - Auth limiter allows 20 requests/15 minutes for settings changes
  artifacts:
    - path: web/lib/ratelimit.ts
      provides: Rate limiter instances for different endpoint types
      exports: [telemetryLimiter, mutationLimiter, authLimiter]
      min_lines: 40
    - path: web/.env.local
      provides: Upstash Redis configuration
      contains: UPSTASH_REDIS_REST_URL
  key_links:
    - from: web/lib/ratelimit.ts
      to: "@upstash/ratelimit"
      via: import and instantiation
      pattern: "import.*@upstash/ratelimit"
    - from: web/lib/ratelimit.ts
      to: "@upstash/redis"
      via: Redis.fromEnv()
      pattern: "Redis\\.fromEnv\\(\\)"
---

<objective>
Establish rate limiting infrastructure to protect API endpoints from resource exhaustion attacks.

Purpose: Address OWASP API4:2023 vulnerability (zero rate limiting currently) by implementing Redis-backed sliding window rate limiters tuned to SDK behavior and user interaction patterns.

Output: Reusable rate limiter instances ready for integration in API routes, with different thresholds for telemetry (high-frequency), mutations (medium-frequency), and auth operations (low-frequency).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-security-hardening/02-RESEARCH.md
@.planning/phases/02-security-hardening/02-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Install Upstash dependencies</name>
  <files>web/package.json, web/package-lock.json</files>
  <action>
Install @upstash/ratelimit and @upstash/redis packages:

```bash
cd web && npm install @upstash/ratelimit@2.x @upstash/redis@1.x
```

These libraries provide serverless-first rate limiting with Redis backend. They work in Next.js Edge runtime, Lambda, and Node.js.

Why these versions:
- @upstash/ratelimit 2.x has sliding window algorithm (prevents boundary exploitation)
- @upstash/redis 1.x is HTTP-based (no persistent connections needed for serverless)
  </action>
  <verify>
```bash
cd web && grep -E "@upstash/(ratelimit|redis)" package.json
```
Should show both packages with correct version ranges.
  </verify>
  <done>package.json contains @upstash/ratelimit and @upstash/redis as dependencies</done>
</task>

<task type="auto">
  <name>Create rate limiter configuration</name>
  <files>web/lib/ratelimit.ts</files>
  <action>
Create web/lib/ratelimit.ts with three rate limiters:

```typescript
import { Ratelimit } from "@upstash/ratelimit";
import { Redis } from "@upstash/redis";

const redis = Redis.fromEnv();

// Telemetry: SDK sends 1Hz, allow 2x buffer = 7200/hour (2 samples/second)
// This prevents legitimate gameplay from hitting rate limits during network retries
export const telemetryLimiter = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(7200, "1 h"),
  analytics: true,
  prefix: "ratelimit:telemetry",
});

// Mutations: job start/complete, ~10-20 per session
// 100/hour allows generous headroom for normal gameplay
export const mutationLimiter = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(100, "1 h"),
  analytics: true,
  prefix: "ratelimit:mutation",
});

// Authenticated: settings changes, key regeneration
// 20/15min prevents abuse while allowing legitimate configuration changes
export const authLimiter = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(20, "15 m"),
  analytics: true,
  prefix: "ratelimit:auth",
});
```

**Implementation notes:**
- Use `Redis.fromEnv()` - automatically reads UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN
- Use `slidingWindow` algorithm - more accurate than fixed window, prevents boundary exploitation
- Enable `analytics: true` - Upstash tracks rate limit hits for monitoring
- Use descriptive prefixes - helps debug which limiter triggered in Redis logs

**Rate limit rationale:**
- Telemetry 7200/hour: SDK sends 3600/hour at 1Hz, 2x buffer handles retries and clock drift
- Mutation 100/hour: Typical 8-hour session has ~20 jobs, 5x buffer very generous
- Auth 20/15min: Settings rarely changed, prevents brute force API key regeneration
  </action>
  <verify>
```bash
grep -E "(telemetryLimiter|mutationLimiter|authLimiter)" web/lib/ratelimit.ts
```
Should show all three limiter exports.

TypeScript compilation check:
```bash
cd web && npx tsc --noEmit lib/ratelimit.ts
```
Should have no type errors.
  </verify>
  <done>web/lib/ratelimit.ts exports three rate limiters with appropriate thresholds and all limiters use sliding window algorithm</done>
</task>

<task type="auto">
  <name>Document Upstash setup requirements</name>
  <files>web/.env.local</files>
  <action>
Add Upstash environment variables to web/.env.local with placeholder values:

```bash
# Upstash Redis (for rate limiting)
# Get these from: https://console.upstash.com/redis
# 1. Create new database (Global recommended for multi-region)
# 2. Copy REST URL and REST Token from database details
UPSTASH_REDIS_REST_URL=https://your-redis.upstash.io
UPSTASH_REDIS_REST_TOKEN=your-token-here
```

**IMPORTANT:** Do NOT commit real credentials. The .env.local file should already be gitignored.

Add comment explaining rate limiter tiers:
```bash
# Rate limiter tiers (configured in lib/ratelimit.ts):
# - Telemetry: 7200 req/hour (SDK sends at 1Hz, 2x buffer)
# - Mutation: 100 req/hour (job operations)
# - Auth: 20 req/15min (settings, key regeneration)
```

If web/.env.local doesn't exist, create it. If it exists, append Upstash section.
  </action>
  <verify>
```bash
grep "UPSTASH_REDIS_REST_URL" web/.env.local
```
Should show the environment variable with placeholder or real value.

Check gitignore:
```bash
git check-ignore web/.env.local
```
Should output "web/.env.local" (file is ignored).
  </verify>
  <done>.env.local contains UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN placeholders with setup instructions</done>
</task>

</tasks>

<verification>
1. Dependencies installed successfully
2. Rate limiter file compiles without TypeScript errors
3. All three limiters exported from lib/ratelimit.ts
4. Environment variables documented in .env.local
5. Sliding window algorithm used for all limiters
</verification>

<success_criteria>
- Developer can import { telemetryLimiter, mutationLimiter, authLimiter } from '@/lib/ratelimit'
- npm run build succeeds with no type errors
- Upstash setup documented in .env.local
- Rate limiter thresholds match research recommendations (7200/hour telemetry, 100/hour mutation, 20/15min auth)
</success_criteria>

<output>
After completion, create `.planning/phases/02-security-hardening/02-01-SUMMARY.md`
</output>
