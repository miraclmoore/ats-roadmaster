---
phase: 02-security-hardening
plan: 04
type: execute
wave: 2
depends_on: [02-01, 02-02, 02-03]
files_modified:
  - web/app/api/telemetry/route.ts
  - web/app/api/jobs/start/route.ts
  - web/app/api/jobs/complete/route.ts
  - web/app/api/user/regenerate-key/route.ts
  - web/lib/supabase/service.ts
autonomous: true

must_haves:
  truths:
    - API routes validate input with Zod before database operations
    - Rate limiting returns 429 with Retry-After header when exceeded
    - Validation errors return 400 with detailed error messages
    - Service role operations include secondary user_id validation
    - Errors are captured in Sentry with PII scrubbed
    - Rate limit headers included in all responses (X-RateLimit-*)
  artifacts:
    - path: web/app/api/telemetry/route.ts
      provides: Secured telemetry endpoint with all layers
      contains: "telemetryLimiter.limit"
      min_lines: 100
    - path: web/app/api/jobs/start/route.ts
      provides: Secured job start endpoint
      contains: "mutationLimiter.limit"
      min_lines: 80
    - path: web/app/api/jobs/complete/route.ts
      provides: Secured job complete endpoint
      contains: "validateUserOwnsResource"
      min_lines: 80
    - path: web/app/api/user/regenerate-key/route.ts
      provides: Secured API key regeneration
      contains: "authLimiter.limit"
      min_lines: 60
  key_links:
    - from: web/app/api/telemetry/route.ts
      to: web/app/api/telemetry/schema.ts
      via: telemetrySchema.safeParse
      pattern: "telemetrySchema\\.safeParse"
    - from: web/app/api/telemetry/route.ts
      to: web/lib/ratelimit.ts
      via: telemetryLimiter.limit
      pattern: "telemetryLimiter\\.limit"
    - from: web/app/api/jobs/complete/route.ts
      to: web/lib/supabase/validation.ts
      via: validateUserOwnsResource call
      pattern: "validateUserOwnsResource"
---

<objective>
Apply security layers (rate limiting, validation, error monitoring) to all API routes in the correct order.

Purpose: Transform vulnerable API routes into production-ready endpoints that prevent DDoS, reject malformed data, and provide observability. Implements SEC-01 through SEC-05 requirements.

Output: All API routes secured with layered defense: rate limiting first (blocks attacks), validation second (rejects bad data), secondary validation third (prevents privilege escalation), Sentry fourth (observes errors).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-security-hardening/02-RESEARCH.md
@.planning/phases/02-security-hardening/02-CONTEXT.md
@web/app/api/telemetry/route.ts
@web/app/api/jobs/start/route.ts
@web/app/api/jobs/complete/route.ts
@web/app/api/user/regenerate-key/route.ts
@web/lib/supabase/service.ts
</context>

<tasks>

<task type="auto">
  <name>Secure telemetry endpoint</name>
  <files>web/app/api/telemetry/route.ts</files>
  <action>
Rewrite web/app/api/telemetry/route.ts with all security layers:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { telemetrySchema } from './schema';
import { telemetryLimiter } from '@/lib/ratelimit';
import { createServiceClient } from '@/lib/supabase/service';
import { validateApiKey, validateUserOwnsResource } from '@/lib/supabase/validation';
import * as Sentry from '@sentry/nextjs';

export async function POST(req: NextRequest) {
  const startTime = Date.now();

  try {
    // 1. Parse JSON (don't trust input yet)
    const body = await req.json();

    // 2. Validate with Zod
    const result = telemetrySchema.safeParse(body);
    if (!result.success) {
      Sentry.captureMessage('Telemetry validation failed', {
        level: 'warning',
        extra: { errors: result.error.format() },
      });

      return NextResponse.json(
        {
          error: 'Validation failed',
          details: result.error.format()
        },
        { status: 400 }
      );
    }

    const data = result.data;

    // 3. Authenticate via API key if provided
    let userId = data.user_id;
    if (data.api_key && !userId) {
      userId = await validateApiKey(data.api_key);
      if (!userId) {
        Sentry.captureMessage('Invalid API key used', {
          level: 'warning',
        });

        return NextResponse.json(
          { error: 'Invalid API key' },
          { status: 401 }
        );
      }
    }

    if (!userId) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }

    // 4. Rate limit (per user)
    const { success, limit, reset, remaining } = await telemetryLimiter.limit(userId);
    if (!success) {
      const retryAfter = Math.ceil((reset - Date.now()) / 1000);

      return NextResponse.json(
        {
          error: 'Rate limit exceeded',
          limit,
          remaining: 0,
          reset: new Date(reset).toISOString(),
        },
        {
          status: 429,
          headers: {
            'Retry-After': String(retryAfter),
            'X-RateLimit-Limit': String(limit),
            'X-RateLimit-Remaining': '0',
            'X-RateLimit-Reset': String(reset),
          }
        }
      );
    }

    // 5. Secondary validation if job_id provided
    if (data.job_id) {
      const ownsJob = await validateUserOwnsResource(userId, 'jobs', data.job_id);
      if (!ownsJob) {
        Sentry.captureMessage('User attempted to update unowned job', {
          level: 'warning',
          extra: { userId, jobId: data.job_id },
        });

        return NextResponse.json(
          { error: 'Unauthorized' },
          { status: 403 }
        );
      }
    }

    // 6. Insert data (using service client)
    const supabase = createServiceClient();
    const { error } = await supabase.from('telemetry').insert({
      user_id: userId,
      job_id: data.job_id || null,
      speed: data.speed,
      rpm: data.rpm,
      gear: data.gear,
      fuel_current: data.fuel_current,
      fuel_capacity: data.fuel_capacity,
      engine_damage: data.engine_damage,
      transmission_damage: data.transmission_damage,
      chassis_damage: data.chassis_damage,
      wheels_damage: data.wheels_damage,
      cabin_damage: data.cabin_damage,
      cargo_damage: data.cargo_damage,
      position_x: data.position_x,
      position_y: data.position_y,
      position_z: data.position_z,
      game_time: data.game_time,
      cruise_control_speed: data.cruise_control_speed,
      cruise_control_enabled: data.cruise_control_enabled,
      parking_brake: data.parking_brake,
      motor_brake: data.motor_brake,
      retarder_level: data.retarder_level,
      air_pressure: data.air_pressure,
      brake_temperature: data.brake_temperature,
      navigation_distance: data.navigation_distance,
      navigation_time: data.navigation_time,
      speed_limit: data.speed_limit,
    });

    if (error) {
      Sentry.captureException(error, {
        extra: { userId, jobId: data.job_id },
      });

      return NextResponse.json(
        { error: 'Failed to insert telemetry' },
        { status: 500 }
      );
    }

    // 7. Success response with rate limit headers
    const duration = Date.now() - startTime;

    return NextResponse.json(
      { success: true },
      {
        headers: {
          'X-RateLimit-Limit': String(limit),
          'X-RateLimit-Remaining': String(remaining),
          'X-RateLimit-Reset': String(reset),
          'X-Response-Time': `${duration}ms`,
        }
      }
    );

  } catch (error) {
    Sentry.captureException(error);

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

**Security layer order:**
1. Parse JSON (untrusted input)
2. Validate schema (reject malformed data early)
3. Authenticate (API key lookup)
4. Rate limit (prevent resource exhaustion)
5. Secondary validation (prevent privilege escalation)
6. Database operation (safe to proceed)
7. Sentry (observe errors)

**Why this order:**
- Validation before rate limiting would allow attackers to exhaust validation CPU
- Rate limiting before auth would leak user existence
- Secondary validation after auth prevents bypassing RLS
  </action>
  <verify>
```bash
cd web && npx tsc --noEmit app/api/telemetry/route.ts
```
Should compile with no errors.

Check security layers:
```bash
grep -E "(telemetrySchema|telemetryLimiter|validateApiKey|Sentry)" web/app/api/telemetry/route.ts
```
Should show all security imports and usage.
  </verify>
  <done>Telemetry endpoint secured with validation, rate limiting, secondary checks, and error monitoring</done>
</task>

<task type="auto">
  <name>Secure job endpoints</name>
  <files>web/app/api/jobs/start/route.ts, web/app/api/jobs/complete/route.ts</files>
  <action>
Update web/app/api/jobs/start/route.ts with security layers:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { jobStartSchema } from './schema';
import { mutationLimiter } from '@/lib/ratelimit';
import { createServiceClient } from '@/lib/supabase/service';
import { validateApiKey } from '@/lib/supabase/validation';
import * as Sentry from '@sentry/nextjs';

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();

    // Validate
    const result = jobStartSchema.safeParse(body);
    if (!result.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: result.error.format() },
        { status: 400 }
      );
    }

    const data = result.data;

    // Authenticate
    let userId = data.user_id;
    if (data.api_key && !userId) {
      userId = await validateApiKey(data.api_key);
      if (!userId) {
        return NextResponse.json({ error: 'Invalid API key' }, { status: 401 });
      }
    }

    if (!userId) {
      return NextResponse.json({ error: 'Authentication required' }, { status: 401 });
    }

    // Rate limit
    const { success, limit, reset, remaining } = await mutationLimiter.limit(userId);
    if (!success) {
      const retryAfter = Math.ceil((reset - Date.now()) / 1000);
      return NextResponse.json(
        { error: 'Rate limit exceeded' },
        {
          status: 429,
          headers: {
            'Retry-After': String(retryAfter),
            'X-RateLimit-Limit': String(limit),
            'X-RateLimit-Remaining': '0',
            'X-RateLimit-Reset': String(reset),
          }
        }
      );
    }

    // Insert job
    const supabase = createServiceClient();
    const { data: job, error } = await supabase
      .from('jobs')
      .insert({
        user_id: userId,
        source_city: data.source_city,
        source_company: data.source_company,
        destination_city: data.destination_city,
        destination_company: data.destination_company,
        cargo_type: data.cargo_type,
        cargo_weight: data.cargo_weight,
        income: data.income,
        distance: data.distance,
        deadline: data.deadline,
        started_at: new Date().toISOString(),
      })
      .select()
      .single();

    if (error) {
      Sentry.captureException(error, { extra: { userId } });
      return NextResponse.json({ error: 'Failed to create job' }, { status: 500 });
    }

    return NextResponse.json(
      { job },
      {
        headers: {
          'X-RateLimit-Limit': String(limit),
          'X-RateLimit-Remaining': String(remaining),
          'X-RateLimit-Reset': String(reset),
        }
      }
    );

  } catch (error) {
    Sentry.captureException(error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
```

Update web/app/api/jobs/complete/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { jobCompleteSchema } from './schema';
import { mutationLimiter } from '@/lib/ratelimit';
import { createServiceClient } from '@/lib/supabase/service';
import { validateApiKey, validateUserOwnsResource } from '@/lib/supabase/validation';
import * as Sentry from '@sentry/nextjs';

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();

    // Validate
    const result = jobCompleteSchema.safeParse(body);
    if (!result.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: result.error.format() },
        { status: 400 }
      );
    }

    const data = result.data;

    // Authenticate
    let userId = data.user_id;
    if (data.api_key && !userId) {
      userId = await validateApiKey(data.api_key);
      if (!userId) {
        return NextResponse.json({ error: 'Invalid API key' }, { status: 401 });
      }
    }

    if (!userId) {
      return NextResponse.json({ error: 'Authentication required' }, { status: 401 });
    }

    // Rate limit
    const { success, limit, reset, remaining } = await mutationLimiter.limit(userId);
    if (!success) {
      const retryAfter = Math.ceil((reset - Date.now()) / 1000);
      return NextResponse.json(
        { error: 'Rate limit exceeded' },
        {
          status: 429,
          headers: {
            'Retry-After': String(retryAfter),
            'X-RateLimit-Limit': String(limit),
            'X-RateLimit-Remaining': '0',
            'X-RateLimit-Reset': String(reset),
          }
        }
      );
    }

    // Secondary validation: user owns this job
    const ownsJob = await validateUserOwnsResource(userId, 'jobs', data.job_id);
    if (!ownsJob) {
      Sentry.captureMessage('User attempted to complete unowned job', {
        level: 'warning',
        extra: { userId, jobId: data.job_id },
      });
      return NextResponse.json({ error: 'Unauthorized' }, { status: 403 });
    }

    // Update job
    const supabase = createServiceClient();
    const { error } = await supabase
      .from('jobs')
      .update({
        completed_at: new Date().toISOString(),
        cargo_damage: data.cargo_damage,
        delivered_late: data.delivered_late,
        fuel_consumed: data.fuel_consumed,
        damage_taken: data.damage_taken,
        avg_speed: data.avg_speed,
        avg_rpm: data.avg_rpm,
      })
      .eq('id', data.job_id);

    if (error) {
      Sentry.captureException(error, { extra: { userId, jobId: data.job_id } });
      return NextResponse.json({ error: 'Failed to complete job' }, { status: 500 });
    }

    return NextResponse.json(
      { success: true },
      {
        headers: {
          'X-RateLimit-Limit': String(limit),
          'X-RateLimit-Remaining': String(remaining),
          'X-RateLimit-Reset': String(reset),
        }
      }
    );

  } catch (error) {
    Sentry.captureException(error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
```
  </action>
  <verify>
```bash
cd web && npx tsc --noEmit app/api/jobs/start/route.ts app/api/jobs/complete/route.ts
```
Should compile successfully.

Check secondary validation in complete:
```bash
grep "validateUserOwnsResource" web/app/api/jobs/complete/route.ts
```
Should show usage before update operation.
  </verify>
  <done>Job endpoints secured with schema validation, rate limiting, secondary checks, and error monitoring</done>
</task>

<task type="auto">
  <name>Secure API key regeneration endpoint</name>
  <files>web/app/api/user/regenerate-key/route.ts</files>
  <action>
Update web/app/api/user/regenerate-key/route.ts with security layers:

```typescript
import { NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { authLimiter } from '@/lib/ratelimit';
import { randomBytes } from 'crypto';
import * as Sentry from '@sentry/nextjs';

export async function POST() {
  try {
    const supabase = await createClient();

    // Authenticate user (uses Supabase session)
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Rate limit (prevent abuse)
    const { success, limit, reset, remaining } = await authLimiter.limit(user.id);
    if (!success) {
      const retryAfter = Math.ceil((reset - Date.now()) / 1000);
      return NextResponse.json(
        { error: 'Rate limit exceeded', reset: new Date(reset) },
        {
          status: 429,
          headers: {
            'Retry-After': String(retryAfter),
            'X-RateLimit-Limit': String(limit),
            'X-RateLimit-Remaining': '0',
            'X-RateLimit-Reset': String(reset),
          }
        }
      );
    }

    // Generate cryptographically secure key
    // Format: rm_ + 64 hex chars (32 bytes = 256 bits of entropy)
    const newApiKey = `rm_${randomBytes(32).toString('hex')}`;

    // Update database (uses RLS - automatically scoped to user)
    const { error: updateError } = await supabase
      .from('user_preferences')
      .upsert({
        user_id: user.id,
        api_key: newApiKey,
        updated_at: new Date().toISOString(),
      });

    if (updateError) {
      Sentry.captureException(updateError, {
        user: { id: user.id },
      });

      return NextResponse.json(
        { error: 'Failed to regenerate API key' },
        { status: 500 }
      );
    }

    // Log security event
    Sentry.captureMessage('API key regenerated', {
      level: 'info',
      user: { id: user.id },
    });

    return NextResponse.json(
      {
        api_key: newApiKey,
        message: 'API key regenerated successfully',
      },
      {
        headers: {
          'X-RateLimit-Limit': String(limit),
          'X-RateLimit-Remaining': String(remaining),
          'X-RateLimit-Reset': String(reset),
        }
      }
    );

  } catch (error) {
    Sentry.captureException(error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
```

**Security notes:**
- Uses authLimiter (20 req/15min) to prevent API key brute forcing
- crypto.randomBytes provides cryptographically secure random values
- Sentry logs key regeneration as security event (info level)
- Rate limit headers inform client when they can retry
  </action>
  <verify>
```bash
cd web && npx tsc --noEmit app/api/user/regenerate-key/route.ts
```
Should compile successfully.

Check cryptographic randomness:
```bash
grep "randomBytes" web/app/api/user/regenerate-key/route.ts
```
Should show crypto.randomBytes usage (not Math.random).
  </verify>
  <done>API key regeneration secured with auth rate limiter and cryptographic key generation</done>
</task>

</tasks>

<verification>
1. All API routes compile without TypeScript errors
2. Telemetry endpoint uses telemetryLimiter (7200/hour)
3. Job endpoints use mutationLimiter (100/hour)
4. Regenerate key uses authLimiter (20/15min)
5. All routes validate input with Zod before operations
6. All routes return 429 with Retry-After header on rate limit
7. Job complete includes secondary validation (validateUserOwnsResource)
8. All routes capture errors in Sentry
9. All success responses include X-RateLimit-* headers
</verification>

<success_criteria>
- All 5 API routes secured with appropriate rate limiters
- Validation errors return 400 with detailed Zod error messages
- Rate limit exceeded returns 429 with Retry-After header
- Secondary validation prevents privilege escalation on job operations
- Sentry captures all errors with PII already scrubbed (from plan 03)
- TypeScript compilation succeeds for all modified routes
</success_criteria>

<output>
After completion, create `.planning/phases/02-security-hardening/02-04-SUMMARY.md`
</output>
