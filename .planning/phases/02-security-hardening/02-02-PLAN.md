---
phase: 02-security-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - web/app/api/telemetry/schema.ts
  - web/app/api/jobs/start/schema.ts
  - web/app/api/jobs/complete/schema.ts
  - web/lib/supabase/validation.ts
  - web/lib/supabase/service.ts
  - web/package.json
  - web/package-lock.json
autonomous: true

must_haves:
  truths:
    - Developer can import Zod schemas for each API endpoint
    - Telemetry schema validates 20+ fields with type and range constraints
    - Job schemas validate required fields and prevent malformed data
    - Validation returns detailed error messages for debugging
    - Secondary validation function confirms user owns resources after API key lookup
    - Service role key is never exposed in client-side code
  artifacts:
    - path: web/app/api/telemetry/schema.ts
      provides: Zod schema for telemetry endpoint validation
      exports: [telemetrySchema, TelemetryInput]
      min_lines: 50
    - path: web/app/api/jobs/start/schema.ts
      provides: Zod schema for job start endpoint
      exports: [jobStartSchema]
      min_lines: 20
    - path: web/app/api/jobs/complete/schema.ts
      provides: Zod schema for job complete endpoint
      exports: [jobCompleteSchema]
      min_lines: 20
    - path: web/lib/supabase/validation.ts
      provides: Secondary validation for service role operations
      exports: [validateApiKey, validateUserOwnsResource]
      min_lines: 40
    - path: web/lib/supabase/service.ts
      provides: Service role client creation
      exports: [createServiceClient]
      min_lines: 15
  key_links:
    - from: web/app/api/telemetry/schema.ts
      to: zod
      via: import and schema definition
      pattern: "import.*zod"
    - from: web/lib/supabase/validation.ts
      to: web/lib/supabase/service.ts
      via: createServiceClient import
      pattern: "import.*createServiceClient"
    - from: web/lib/supabase/service.ts
      to: SUPABASE_SERVICE_ROLE_KEY
      via: env var access in server-side code only
      pattern: "SUPABASE_SERVICE_ROLE_KEY"
---

<objective>
Implement runtime input validation with Zod schemas for all API endpoints to prevent OWASP API4:2023 validation vulnerabilities. Audit codebase to ensure service role key is never exposed client-side.

Purpose: Replace minimal string-presence validation with comprehensive type, range, and format validation. Add secondary user_id validation when using service role to bypass RLS (defense in depth). Verify service role key isolation.

Output: Zod schemas co-located with API routes for maintainability, validation utility functions for service role security, and documented audit of service role key usage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-security-hardening/02-RESEARCH.md
@.planning/phases/02-security-hardening/02-CONTEXT.md
@web/app/api/telemetry/route.ts
@web/app/api/jobs/start/route.ts
@web/app/api/jobs/complete/route.ts
</context>

<tasks>

<task type="auto">
  <name>Install Zod dependency</name>
  <files>web/package.json, web/package-lock.json</files>
  <action>
Install Zod for runtime schema validation:

```bash
cd web && npm install zod@3.x
```

Zod 3.x provides:
- TypeScript-first validation (infer types from schemas)
- Composable schemas (reuse common patterns)
- Detailed error formatting
- Zero runtime dependencies
  </action>
  <verify>
```bash
cd web && grep "\"zod\"" package.json
```
Should show zod as a dependency with version ^3.x.
  </verify>
  <done>package.json contains zod as a dependency</done>
</task>

<task type="auto">
  <name>Create telemetry validation schema</name>
  <files>web/app/api/telemetry/schema.ts</files>
  <action>
Create web/app/api/telemetry/schema.ts with comprehensive validation:

```typescript
import { z } from "zod";

export const telemetrySchema = z.object({
  // Auth (one required)
  user_id: z.string().uuid().optional(),
  api_key: z.string().regex(/^rm_[a-f0-9]{64}$/).optional(),

  // Truck state - realistic game limits
  speed: z.number().min(0).max(150), // mph, max governed truck speed ~80-90 but allow buffer
  rpm: z.number().int().min(0).max(3000), // typical truck redline ~2000-2500
  gear: z.number().int().min(-6).max(18), // reverse gears + forward gears
  fuel_current: z.number().min(0), // gallons, no upper limit (depends on tank size)
  fuel_capacity: z.number().positive(), // must be > 0

  // Damage (0.0-1.0 range from SDK)
  engine_damage: z.number().min(0).max(1),
  transmission_damage: z.number().min(0).max(1),
  chassis_damage: z.number().min(0).max(1),
  wheels_damage: z.number().min(0).max(1),
  cabin_damage: z.number().min(0).max(1),
  cargo_damage: z.number().min(0).max(1),

  // Position (no constraints - game world is arbitrary coordinates)
  position_x: z.number(),
  position_y: z.number(),
  position_z: z.number(),

  // Time
  game_time: z.string().datetime().optional(), // ISO 8601 format

  // Optional enhanced telemetry
  job_id: z.string().uuid().optional(),
  cruise_control_speed: z.number().min(0).max(150).optional(),
  cruise_control_enabled: z.boolean().optional(),
  parking_brake: z.boolean().optional(),
  motor_brake: z.boolean().optional(),
  retarder_level: z.number().int().min(0).max(5).optional(), // typical 0-5 levels
  air_pressure: z.number().min(0).max(200).optional(), // PSI, typical 90-150
  brake_temperature: z.number().min(0).max(1000).optional(), // degrees, allow headroom
  navigation_distance: z.number().min(0).optional(), // miles
  navigation_time: z.number().min(0).optional(), // minutes
  speed_limit: z.number().min(0).max(150).optional(), // mph
}).refine((data) => data.user_id || data.api_key, {
  message: "Either user_id or api_key must be provided",
});

export type TelemetryInput = z.infer<typeof telemetrySchema>;
```

**Validation strategy:**
- Min/max based on realistic game limits (prevents absurd values like speed: 999999)
- Damage fields constrained to 0.0-1.0 range (SDK contract)
- Position unconstrained (game world coordinates are arbitrary)
- API key format validated (rm_ + 64 hex chars per SEC-04 requirement)
- Custom refinement ensures auth is provided (user_id OR api_key)
  </action>
  <verify>
```bash
cd web && npx tsc --noEmit app/api/telemetry/schema.ts
```
Should compile with no type errors.
  </verify>
  <done>web/app/api/telemetry/schema.ts exports telemetrySchema with 20+ validated fields and TelemetryInput type</done>
</task>

<task type="auto">
  <name>Create job validation schemas</name>
  <files>web/app/api/jobs/start/schema.ts, web/app/api/jobs/complete/schema.ts</files>
  <action>
Create web/app/api/jobs/start/schema.ts:

```typescript
import { z } from "zod";

export const jobStartSchema = z.object({
  // Auth
  user_id: z.string().uuid().optional(),
  api_key: z.string().regex(/^rm_[a-f0-9]{64}$/).optional(),

  // Job details from SDK
  source_city: z.string().min(1).max(100),
  source_company: z.string().min(1).max(100).optional(),
  destination_city: z.string().min(1).max(100),
  destination_company: z.string().min(1).max(100).optional(),
  cargo_type: z.string().min(1).max(100),
  cargo_weight: z.number().int().min(0).max(100000).optional(), // lbs, max realistic trailer load

  // Financial
  income: z.number().int().min(0).max(1000000), // $ per job, typical $1k-$10k
  distance: z.number().int().min(1).max(10000), // miles, max cross-map distance

  // Timing
  deadline: z.string().datetime().optional(), // ISO 8601
}).refine((data) => data.user_id || data.api_key, {
  message: "Either user_id or api_key must be provided",
});

export type JobStartInput = z.infer<typeof jobStartSchema>;
```

Create web/app/api/jobs/complete/schema.ts:

```typescript
import { z } from "zod";

export const jobCompleteSchema = z.object({
  // Auth
  user_id: z.string().uuid().optional(),
  api_key: z.string().regex(/^rm_[a-f0-9]{64}$/).optional(),

  // Job reference
  job_id: z.string().uuid(),

  // Completion data from SDK
  cargo_damage: z.number().min(0).max(1),
  delivered_late: z.boolean(),

  // Performance metrics (calculated from telemetry)
  fuel_consumed: z.number().min(0).optional(),
  damage_taken: z.number().min(0).max(1).optional(),
  avg_speed: z.number().min(0).max(150).optional(),
  avg_rpm: z.number().int().min(0).max(3000).optional(),
}).refine((data) => data.user_id || data.api_key, {
  message: "Either user_id or api_key must be provided",
});

export type JobCompleteInput = z.infer<typeof jobCompleteSchema>;
```

**Design notes:**
- Co-locate schemas with routes (schema.ts next to route.ts)
- String fields have max length to prevent DOS via huge payloads
- Numeric fields have realistic upper bounds from game mechanics
- Export TypeScript types via z.infer for use in route handlers
  </action>
  <verify>
```bash
cd web && npx tsc --noEmit app/api/jobs/start/schema.ts app/api/jobs/complete/schema.ts
```
Should compile with no errors.

Check exports:
```bash
grep -E "(jobStartSchema|jobCompleteSchema)" web/app/api/jobs/start/schema.ts web/app/api/jobs/complete/schema.ts
```
Should show schema exports in both files.
  </verify>
  <done>Job validation schemas created with type safety and realistic constraints</done>
</task>

<task type="auto">
  <name>Create secondary validation utilities</name>
  <files>web/lib/supabase/validation.ts, web/lib/supabase/service.ts</files>
  <action>
**Step 1: Check if service.ts exists and create if missing**

```bash
# Check if service.ts exists
if [ ! -f web/lib/supabase/service.ts ]; then
  echo "service.ts not found - creating it"
fi
```

If web/lib/supabase/service.ts does NOT exist, create it:

```typescript
import { createClient } from '@supabase/supabase-js';

export function createServiceClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;

  if (!supabaseUrl || !supabaseServiceKey) {
    throw new Error('Missing Supabase environment variables');
  }

  return createClient(supabaseUrl, supabaseServiceKey, {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
    },
  });
}
```

**Step 2: Create validation.ts**

Create web/lib/supabase/validation.ts for service role security:

```typescript
import { createServiceClient } from "./service";

/**
 * Validates an API key and returns the associated user_id.
 * Uses service role client to bypass RLS for API key lookup.
 *
 * @param apiKey - API key in format rm_[64 hex chars]
 * @returns user_id if valid, null if invalid
 */
export async function validateApiKey(apiKey: string): Promise<string | null> {
  const supabase = createServiceClient();

  const { data: prefs, error } = await supabase
    .from('user_preferences')
    .select('user_id')
    .eq('api_key', apiKey)
    .single();

  if (error || !prefs) {
    return null;
  }

  return prefs.user_id;
}

/**
 * Secondary validation: confirms user owns a resource.
 * Use AFTER service role operations to prevent unauthorized access.
 * Defense in depth - ensures API key lookup didn't bypass intended RLS.
 *
 * @param userId - Authenticated user ID
 * @param table - Table name (jobs, telemetry, etc.)
 * @param resourceId - Resource UUID to check
 * @returns true if user owns resource, false otherwise
 */
export async function validateUserOwnsResource(
  userId: string,
  table: string,
  resourceId: string
): Promise<boolean> {
  const supabase = createServiceClient();

  const { data, error } = await supabase
    .from(table)
    .select('user_id')
    .eq('id', resourceId)
    .single();

  if (error || !data) {
    return false;
  }

  // Secondary validation: confirm user_id matches
  return data.user_id === userId;
}
```

**Security rationale:**
- validateApiKey: Encapsulates service role usage for API key lookup
- validateUserOwnsResource: Prevents privilege escalation after API key lookup
- Defense in depth: Even if API key is compromised, can't access other users' data
- Used in API routes BEFORE performing operations on user resources
  </action>
  <verify>
```bash
# Verify service.ts exists and exports createServiceClient
ls web/lib/supabase/service.ts && grep "export.*createServiceClient" web/lib/supabase/service.ts
```
Should show file exists and exports the function.

```bash
cd web && npx tsc --noEmit lib/supabase/validation.ts
```
Should compile with no errors.

Check imports:
```bash
grep "createServiceClient" web/lib/supabase/validation.ts
```
Should show import from ./service.
  </verify>
  <done>web/lib/supabase/validation.ts exports validateApiKey and validateUserOwnsResource functions with comprehensive JSDoc, and web/lib/supabase/service.ts exists with createServiceClient</done>
</task>

<task type="auto">
  <name>Audit service role key usage (SEC-03 coverage)</name>
  <files>None (audit only)</files>
  <action>
Audit codebase to ensure SUPABASE_SERVICE_ROLE_KEY is never exposed in client-side code:

**Step 1: Search for service role key references**

```bash
cd web && grep -r "SUPABASE_SERVICE_ROLE_KEY" app/ components/ lib/ --include="*.ts" --include="*.tsx" --include="*.js" --include="*.jsx"
```

**Step 2: Verify each reference is server-side**

For each file found, verify it's a server-side context:
- ✅ Allowed: `app/api/**/route.ts` (API routes are server-only)
- ✅ Allowed: `lib/supabase/service.ts` (utility for server usage)
- ✅ Allowed: Server Components (files without 'use client' directive at top)
- ❌ BLOCKED: Client Components (files with 'use client' at top)
- ❌ BLOCKED: `components/*` (most are client components)
- ❌ BLOCKED: Any file in `app/(dashboard)/**` that has 'use client'

**Step 3: Check client.ts for service role usage**

```bash
grep "SUPABASE_SERVICE_ROLE_KEY" web/lib/supabase/client.ts
```
Should return NOTHING. If found, this is a critical security issue.

**Step 4: Verify build output doesn't include service role key**

```bash
cd web && npm run build 2>&1 | grep -i "SUPABASE_SERVICE_ROLE_KEY" || echo "✓ Service role key not in build output"
```

**Step 5: Document audit results**

Create a summary comment in the SUMMARY.md after execution:
- List all files that reference SUPABASE_SERVICE_ROLE_KEY
- Confirm each is server-side
- Flag any client-side exposures as CRITICAL SECURITY ISSUES
- Verify client.ts does NOT import or reference service role key

**Expected result:**
Only `web/lib/supabase/service.ts` and server-side API route files should reference the service role key.
  </action>
  <verify>
```bash
# Verify no client-side usage
cd web && ! grep -r "SUPABASE_SERVICE_ROLE_KEY" components/ --include="*.tsx" --include="*.ts"
```
Exit code 0 means NO matches in components/ (good).

```bash
# Verify client.ts is clean
cd web && ! grep "SUPABASE_SERVICE_ROLE_KEY" lib/supabase/client.ts
```
Exit code 0 means NO matches in client.ts (good).

```bash
# List server-side usage (should only be service.ts)
cd web && grep -l "SUPABASE_SERVICE_ROLE_KEY" lib/supabase/service.ts
```
Should return only service.ts.
  </verify>
  <done>Audit confirms SUPABASE_SERVICE_ROLE_KEY is only used in server-side files (service.ts and API routes), never exposed in client components or client.ts</done>
</task>

</tasks>

<verification>
1. Zod installed successfully
2. All schema files compile without TypeScript errors
3. Telemetry schema validates 20+ fields with constraints
4. Job schemas validate required fields and data types
5. Validation utilities created for secondary security checks
6. All schemas export TypeScript types via z.infer
7. service.ts exists and exports createServiceClient BEFORE creating validation.ts (checked in Task 4)
8. Service role key is NEVER exposed in client-side code (audited in Task 5)
</verification>

<success_criteria>
- Developer can import and use telemetrySchema, jobStartSchema, jobCompleteSchema
- Schema validation catches invalid data (tested via safeParse)
- TypeScript types inferred from Zod schemas (TelemetryInput, JobStartInput, JobCompleteInput)
- Secondary validation functions ready for use in API routes
- All files compile successfully with npx tsc --noEmit
- validation.ts successfully imports createServiceClient from service.ts (service.ts created if missing)
- SUPABASE_SERVICE_ROLE_KEY only appears in server-side files (service.ts and API routes)
- No client-side exposure of service role key confirmed via audit
</success_criteria>

<output>
After completion, create `.planning/phases/02-security-hardening/02-02-SUMMARY.md`
</output>
