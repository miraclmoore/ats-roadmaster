---
phase: 02-security-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - web/app/api/telemetry/schema.ts
  - web/app/api/jobs/start/schema.ts
  - web/app/api/jobs/complete/schema.ts
  - web/lib/supabase/validation.ts
  - web/package.json
  - web/package-lock.json
autonomous: true

must_haves:
  truths:
    - Developer can import Zod schemas for each API endpoint
    - Telemetry schema validates 20+ fields with type and range constraints
    - Job schemas validate required fields and prevent malformed data
    - Validation returns detailed error messages for debugging
    - Secondary validation function confirms user owns resources after API key lookup
  artifacts:
    - path: web/app/api/telemetry/schema.ts
      provides: Zod schema for telemetry endpoint validation
      exports: [telemetrySchema, TelemetryInput]
      min_lines: 50
    - path: web/app/api/jobs/start/schema.ts
      provides: Zod schema for job start endpoint
      exports: [jobStartSchema]
      min_lines: 20
    - path: web/app/api/jobs/complete/schema.ts
      provides: Zod schema for job complete endpoint
      exports: [jobCompleteSchema]
      min_lines: 20
    - path: web/lib/supabase/validation.ts
      provides: Secondary validation for service role operations
      exports: [validateApiKey, validateUserOwnsResource]
      min_lines: 40
  key_links:
    - from: web/app/api/telemetry/schema.ts
      to: zod
      via: import and schema definition
      pattern: "import.*zod"
    - from: web/lib/supabase/validation.ts
      to: web/lib/supabase/service.ts
      via: createServiceClient import
      pattern: "import.*createServiceClient"
---

<objective>
Implement runtime input validation with Zod schemas for all API endpoints to prevent OWASP API4:2023 validation vulnerabilities.

Purpose: Replace minimal string-presence validation with comprehensive type, range, and format validation. Add secondary user_id validation when using service role to bypass RLS (defense in depth).

Output: Zod schemas co-located with API routes for maintainability, plus validation utility functions for service role security.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-security-hardening/02-RESEARCH.md
@.planning/phases/02-security-hardening/02-CONTEXT.md
@web/app/api/telemetry/route.ts
@web/app/api/jobs/start/route.ts
@web/app/api/jobs/complete/route.ts
</context>

<tasks>

<task type="auto">
  <name>Install Zod dependency</name>
  <files>web/package.json, web/package-lock.json</files>
  <action>
Install Zod for runtime schema validation:

```bash
cd web && npm install zod@3.x
```

Zod 3.x provides:
- TypeScript-first validation (infer types from schemas)
- Composable schemas (reuse common patterns)
- Detailed error formatting
- Zero runtime dependencies
  </action>
  <verify>
```bash
cd web && grep "\"zod\"" package.json
```
Should show zod as a dependency with version ^3.x.
  </verify>
  <done>package.json contains zod as a dependency</done>
</task>

<task type="auto">
  <name>Create telemetry validation schema</name>
  <files>web/app/api/telemetry/schema.ts</files>
  <action>
Create web/app/api/telemetry/schema.ts with comprehensive validation:

```typescript
import { z } from "zod";

export const telemetrySchema = z.object({
  // Auth (one required)
  user_id: z.string().uuid().optional(),
  api_key: z.string().regex(/^rm_[a-f0-9]{64}$/).optional(),

  // Truck state - realistic game limits
  speed: z.number().min(0).max(150), // mph, max governed truck speed ~80-90 but allow buffer
  rpm: z.number().int().min(0).max(3000), // typical truck redline ~2000-2500
  gear: z.number().int().min(-6).max(18), // reverse gears + forward gears
  fuel_current: z.number().min(0), // gallons, no upper limit (depends on tank size)
  fuel_capacity: z.number().positive(), // must be > 0

  // Damage (0.0-1.0 range from SDK)
  engine_damage: z.number().min(0).max(1),
  transmission_damage: z.number().min(0).max(1),
  chassis_damage: z.number().min(0).max(1),
  wheels_damage: z.number().min(0).max(1),
  cabin_damage: z.number().min(0).max(1),
  cargo_damage: z.number().min(0).max(1),

  // Position (no constraints - game world is arbitrary coordinates)
  position_x: z.number(),
  position_y: z.number(),
  position_z: z.number(),

  // Time
  game_time: z.string().datetime().optional(), // ISO 8601 format

  // Optional enhanced telemetry
  job_id: z.string().uuid().optional(),
  cruise_control_speed: z.number().min(0).max(150).optional(),
  cruise_control_enabled: z.boolean().optional(),
  parking_brake: z.boolean().optional(),
  motor_brake: z.boolean().optional(),
  retarder_level: z.number().int().min(0).max(5).optional(), // typical 0-5 levels
  air_pressure: z.number().min(0).max(200).optional(), // PSI, typical 90-150
  brake_temperature: z.number().min(0).max(1000).optional(), // degrees, allow headroom
  navigation_distance: z.number().min(0).optional(), // miles
  navigation_time: z.number().min(0).optional(), // minutes
  speed_limit: z.number().min(0).max(150).optional(), // mph
}).refine((data) => data.user_id || data.api_key, {
  message: "Either user_id or api_key must be provided",
});

export type TelemetryInput = z.infer<typeof telemetrySchema>;
```

**Validation strategy:**
- Min/max based on realistic game limits (prevents absurd values like speed: 999999)
- Damage fields constrained to 0.0-1.0 range (SDK contract)
- Position unconstrained (game world coordinates are arbitrary)
- API key format validated (rm_ + 64 hex chars per SEC-04 requirement)
- Custom refinement ensures auth is provided (user_id OR api_key)
  </action>
  <verify>
```bash
cd web && npx tsc --noEmit app/api/telemetry/schema.ts
```
Should compile with no type errors.

Test schema validation:
```bash
cd web && node -e "
const { telemetrySchema } = require('./app/api/telemetry/schema.ts');
const result = telemetrySchema.safeParse({ user_id: 'invalid' });
console.log(result.success ? 'FAIL: Should reject invalid UUID' : 'PASS');
"
```
  </verify>
  <done>web/app/api/telemetry/schema.ts exports telemetrySchema with 20+ validated fields and TelemetryInput type</done>
</task>

<task type="auto">
  <name>Create job validation schemas</name>
  <files>web/app/api/jobs/start/schema.ts, web/app/api/jobs/complete/schema.ts</files>
  <action>
Create web/app/api/jobs/start/schema.ts:

```typescript
import { z } from "zod";

export const jobStartSchema = z.object({
  // Auth
  user_id: z.string().uuid().optional(),
  api_key: z.string().regex(/^rm_[a-f0-9]{64}$/).optional(),

  // Job details from SDK
  source_city: z.string().min(1).max(100),
  source_company: z.string().min(1).max(100).optional(),
  destination_city: z.string().min(1).max(100),
  destination_company: z.string().min(1).max(100).optional(),
  cargo_type: z.string().min(1).max(100),
  cargo_weight: z.number().int().min(0).max(100000).optional(), // lbs, max realistic trailer load

  // Financial
  income: z.number().int().min(0).max(1000000), // $ per job, typical $1k-$10k
  distance: z.number().int().min(1).max(10000), // miles, max cross-map distance

  // Timing
  deadline: z.string().datetime().optional(), // ISO 8601
}).refine((data) => data.user_id || data.api_key, {
  message: "Either user_id or api_key must be provided",
});

export type JobStartInput = z.infer<typeof jobStartSchema>;
```

Create web/app/api/jobs/complete/schema.ts:

```typescript
import { z } from "zod";

export const jobCompleteSchema = z.object({
  // Auth
  user_id: z.string().uuid().optional(),
  api_key: z.string().regex(/^rm_[a-f0-9]{64}$/).optional(),

  // Job reference
  job_id: z.string().uuid(),

  // Completion data from SDK
  cargo_damage: z.number().min(0).max(1),
  delivered_late: z.boolean(),

  // Performance metrics (calculated from telemetry)
  fuel_consumed: z.number().min(0).optional(),
  damage_taken: z.number().min(0).max(1).optional(),
  avg_speed: z.number().min(0).max(150).optional(),
  avg_rpm: z.number().int().min(0).max(3000).optional(),
}).refine((data) => data.user_id || data.api_key, {
  message: "Either user_id or api_key must be provided",
});

export type JobCompleteInput = z.infer<typeof jobCompleteSchema>;
```

**Design notes:**
- Co-locate schemas with routes (schema.ts next to route.ts)
- String fields have max length to prevent DOS via huge payloads
- Numeric fields have realistic upper bounds from game mechanics
- Export TypeScript types via z.infer for use in route handlers
  </action>
  <verify>
```bash
cd web && npx tsc --noEmit app/api/jobs/start/schema.ts app/api/jobs/complete/schema.ts
```
Should compile with no errors.

Check exports:
```bash
grep -E "(jobStartSchema|jobCompleteSchema)" web/app/api/jobs/start/schema.ts web/app/api/jobs/complete/schema.ts
```
Should show schema exports in both files.
  </verify>
  <done>Job validation schemas created with type safety and realistic constraints</done>
</task>

<task type="auto">
  <name>Create secondary validation utilities</name>
  <files>web/lib/supabase/validation.ts</files>
  <action>
Create web/lib/supabase/validation.ts for service role security:

```typescript
import { createServiceClient } from "./service";

/**
 * Validates an API key and returns the associated user_id.
 * Uses service role client to bypass RLS for API key lookup.
 *
 * @param apiKey - API key in format rm_[64 hex chars]
 * @returns user_id if valid, null if invalid
 */
export async function validateApiKey(apiKey: string): Promise<string | null> {
  const supabase = createServiceClient();

  const { data: prefs, error } = await supabase
    .from('user_preferences')
    .select('user_id')
    .eq('api_key', apiKey)
    .single();

  if (error || !prefs) {
    return null;
  }

  return prefs.user_id;
}

/**
 * Secondary validation: confirms user owns a resource.
 * Use AFTER service role operations to prevent unauthorized access.
 * Defense in depth - ensures API key lookup didn't bypass intended RLS.
 *
 * @param userId - Authenticated user ID
 * @param table - Table name (jobs, telemetry, etc.)
 * @param resourceId - Resource UUID to check
 * @returns true if user owns resource, false otherwise
 */
export async function validateUserOwnsResource(
  userId: string,
  table: string,
  resourceId: string
): Promise<boolean> {
  const supabase = createServiceClient();

  const { data, error } = await supabase
    .from(table)
    .select('user_id')
    .eq('id', resourceId)
    .single();

  if (error || !data) {
    return false;
  }

  // Secondary validation: confirm user_id matches
  return data.user_id === userId;
}
```

**Security rationale:**
- validateApiKey: Encapsulates service role usage for API key lookup
- validateUserOwnsResource: Prevents privilege escalation after API key lookup
- Defense in depth: Even if API key is compromised, can't access other users' data
- Used in API routes BEFORE performing operations on user resources
  </action>
  <verify>
```bash
cd web && npx tsc --noEmit lib/supabase/validation.ts
```
Should compile with no errors.

Check imports:
```bash
grep "createServiceClient" web/lib/supabase/validation.ts
```
Should show import from ./service.
  </verify>
  <done>web/lib/supabase/validation.ts exports validateApiKey and validateUserOwnsResource functions with comprehensive JSDoc</done>
</task>

</tasks>

<verification>
1. Zod installed successfully
2. All schema files compile without TypeScript errors
3. Telemetry schema validates 20+ fields with constraints
4. Job schemas validate required fields and data types
5. Validation utilities created for secondary security checks
6. All schemas export TypeScript types via z.infer
</verification>

<success_criteria>
- Developer can import and use telemetrySchema, jobStartSchema, jobCompleteSchema
- Schema validation catches invalid data (tested via safeParse)
- TypeScript types inferred from Zod schemas (TelemetryInput, JobStartInput, JobCompleteInput)
- Secondary validation functions ready for use in API routes
- All files compile successfully with npx tsc --noEmit
</success_criteria>

<output>
After completion, create `.planning/phases/02-security-hardening/02-02-SUMMARY.md`
</output>
